Objective:
This document defines the reference architecture and behavioral standards for Kubernetes Scaling Jobs (KSJ) used for asynchronous message processing in our platform. It outlines how we prefer a KSJ to function, handles edge cases, and defines default configurations for KEDA, SQS, and job lifecycle.


Summary
1) A Kubernetes Scaling Job (KSJ) is designed to:
2) Dynamically scale based on queue depth using KEDA
3) Process messages from SQS
4) Ensure messages are reliably handled, retried if needed, and never lost silently
5) Provide observability through structured logs
6) Be resilient to failures and handle graceful shutdowns

Reference Workflow:
***
+-------------+ +------------+ +----------------+
| Developer/API | -----> | S3 | -----> | SQS |
+-------------+ +------------+ +----------------+
|
v
+---------------------------+
| KEDA ScaledObject |
| (SQS Trigger) |
+---------------------------+
|
v
+--------------------------+
| K8s ScaledJob (KSJ)|
+--------------------------+
|
+------------------------+-------------------+-------------------------+
| | |
Read SQS Msg Execute Business Logic Log + Retry Policy
| | |
On Success On Success On Failure
| | |
Delete SQS Msg Terminate Pod Let message timeout (remain in
queue)



    +------------------------------+
          |     Kubernetes Scaling Job   |
          |    (KSJ Worker Container)    |
          +------------------------------+
                            |
                            v
             +------------------------------+
             |  Read Message from SQS       |  ← Visibility Timeout Starts
             +------------------------------+
                            |
                            v
             +------------------------------+
             |  Start Background Thread     |
             |  to Extend Visibility        |
             +------------------------------+
                            |
                            v
             +------------------------------+
             |  Execute Job Logic           |
             |  (e.g. process order, image) |
             +------------------------------+
                            |
            / \                             \
           /   \                             \ SIGTERM received?
   Success     Failure                        → Set shutdown_event
     |             |                          → Do NOT delete message
     |             v
     |     +-----------------------------+
     |     |  Log Error, Let Timeout Expire
     |     +-----------------------------+
     |
     v
+-----------------------------+
|   Delete Message from SQS   |
+-----------------------------+

Implementation Guidelines
1. Message Visibility Timeout:
| Feature               | Recommendation                                                        |
| --------------------- | --------------------------------------------------------------------- |
| **Initial Timeout**   | 30–60 seconds (via `ReceiveMessage`)                                  |
| **Dynamic Extension** | Yes – Extend during long processing using `ChangeMessageVisibility` |
| **Maximum Timeout**   | Should match max expected processing time (e.g., 10 minutes)          |
| **On Failure**        | Don’t delete message – let it become visible again after timeout      |


Initial Timeout (30 seconds)

```VISIBILITY_TIMEOUT = int(os.getenv("INITIAL_VISIBILITY_TIMEOUT", 30))  # Default 30s

response = sqs.receive_message(
    QueueUrl=QUEUE_URL,
    MaxNumberOfMessages=1,
    WaitTimeSeconds=10,
    VisibilityTimeout=VISIBILITY_TIMEOUT  # <-- Initial visibility timeout
)
```

Dynamic Extension:
```
EXTEND_INTERVAL = int(os.getenv("VISIBILITY_EXTENSION_INTERVAL", 10))  # every 10s
EXTEND_BY = int(os.getenv("EXTEND_BY", 30))  # extend by 30s

def extend_visibility_timeout():
    while not shutdown_event.is_set():
        time.sleep(EXTEND_INTERVAL)
        if receipt_handle:
            try:
                logging.info(f"Extending visibility timeout by {EXTEND_BY}s")
                sqs.change_message_visibility(
                    QueueUrl=QUEUE_URL,
                    ReceiptHandle=receipt_handle,
                    VisibilityTimeout=EXTEND_BY
                )
            except Exception as e:
                logging.error(f"Failed to extend visibility timeout: {e}")
```
A background thread runs every EXTEND_INTERVAL to extend the timeout while the job is still working.


On Failure – Do Not Delete Message
```
try:
    process_message(message_body)

    if shutdown_event.is_set():
        logging.warning("Job interrupted. Message will return to queue.")
    else:
        logging.info("Deleting message from queue")
        sqs.delete_message(
            QueueUrl=QUEUE_URL,
            ReceiptHandle=receipt_handle
        )

except Exception as e:
    logging.error(f"Job failed with exception: {e}")
    # Message is NOT deleted — becomes visible again after timeout
```
If the job crashes or is interrupted (SIGTERM), the message is left in SQS and reappears after timeout.
